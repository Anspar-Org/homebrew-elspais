name: Update Homebrew Formula

on:
  repository_dispatch:
    types: [update-formula]
  workflow_dispatch:
    inputs:
      package:
        description: 'Package to update (elspais or anspar-wf)'
        required: true
        type: choice
        options:
          - elspais
          - anspar-wf
      version:
        description: 'Version to update to (e.g., 0.72.0)'
        required: true
        type: string

jobs:
  update:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install pip-tools
        run: pip install pip-tools

      - name: Determine package and version
        id: params
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            PACKAGE="${{ inputs.package }}"
            VERSION="${{ inputs.version }}"
          else
            PACKAGE="${{ github.event.client_payload.package }}"
            VERSION="${{ github.event.client_payload.version }}"
          fi
          # Default to elspais for backwards compatibility
          PACKAGE="${PACKAGE:-elspais}"
          echo "package=${PACKAGE}" >> "$GITHUB_OUTPUT"
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "Updating ${PACKAGE} to v${VERSION}"

      - name: Update elspais formulas
        if: steps.params.outputs.package == 'elspais'
        env:
          VERSION: ${{ steps.params.outputs.version }}
        run: |
          python3 << 'PYEOF'
          import json, os, re, subprocess, time, urllib.request, urllib.error

          version = os.environ["VERSION"]

          # --- Phase 1: Wait for PyPI JSON API to index the new version ---
          for attempt in range(12):
              try:
                  urllib.request.urlopen(f"https://pypi.org/pypi/elspais/{version}/json")
                  print(f"PyPI JSON API has elspais {version} (attempt {attempt+1})")
                  break
              except urllib.error.HTTPError:
                  print(f"Waiting for PyPI JSON API to index elspais {version}... (attempt {attempt+1}/12)")
                  time.sleep(10)
          else:
              raise RuntimeError(f"PyPI JSON API never indexed elspais {version} after 2 minutes")

          # --- Phase 2: Wait for pip's Simple API / CDN to propagate ---
          for attempt in range(18):
              result = subprocess.run(
                  ["pip", "install", "--dry-run", "--no-deps", f"elspais=={version}"],
                  capture_output=True, text=True
              )
              if result.returncode == 0:
                  print(f"pip can resolve elspais {version} (attempt {attempt+1})")
                  break
              print(f"Waiting for pip index to propagate elspais {version}... (attempt {attempt+1}/18)")
              time.sleep(10)
          else:
              raise RuntimeError(f"pip could not resolve elspais {version} after 3 minutes")

          # --- Fetch elspais sdist info ---
          with urllib.request.urlopen(f"https://pypi.org/pypi/elspais/{version}/json") as r:
              pkg = json.loads(r.read())
          sdist = next(f for f in pkg["urls"] if f["packagetype"] == "sdist")
          sdist_url = sdist["url"]
          sdist_sha = sdist["digests"]["sha256"]
          print(f"elspais {version}: {sdist_sha[:16]}...")

          # --- Resolve all dependencies for elspais[all] (with retry) ---
          for compile_attempt in range(3):
              result = subprocess.run(
                  ["pip-compile", "--no-header", "--no-annotate", "--output-file=-", "-"],
                  input=f"elspais[all]=={version}\n",
                  capture_output=True, text=True
              )
              if result.returncode == 0:
                  break
              print(f"pip-compile attempt {compile_attempt+1}/3 failed, retrying in 15s...")
              print(f"stderr: {result.stderr[-300:]}")
              time.sleep(15)
          if result.returncode != 0:
              raise RuntimeError(f"pip-compile failed after 3 attempts:\n{result.stderr}")

          deps = {}
          for line in result.stdout.strip().split("\n"):
              line = line.strip()
              if not line or line.startswith("#"):
                  continue
              clean = re.sub(r'\[.*?\]', '', line)
              if "==" not in clean:
                  continue
              name, ver = clean.split("==", 1)
              if name == "elspais":
                  continue
              if name in ("cryptography", "cffi", "pycparser"):
                  print(f"  Skipping {name}=={ver} (crypto chain, not needed)")
                  continue
              deps[name] = ver
          print(f"Resolved {len(deps)} dependencies")

          # --- Fetch sdist URL and SHA for each dependency ---
          resources = []
          for name, ver in sorted(deps.items()):
              try:
                  with urllib.request.urlopen(f"https://pypi.org/pypi/{name}/{ver}/json") as r:
                      dep_pkg = json.loads(r.read())
                  dep_sdist = next(
                      (f for f in dep_pkg["urls"] if f["packagetype"] == "sdist"), None
                  )
                  if dep_sdist:
                      resources.append((name, dep_sdist["url"], dep_sdist["digests"]["sha256"]))
                      print(f"  {name}=={ver}: OK")
                  else:
                      print(f"  WARNING: No sdist for {name}=={ver}")
              except Exception as e:
                  print(f"  ERROR: {name}=={ver}: {e}")
                  raise

          # --- Generate resource blocks ---
          resource_lines = []
          for name, url, sha in resources:
              resource_lines.append(f'  resource "{name}" do')
              resource_lines.append(f'    url "{url}"')
              resource_lines.append(f'    sha256 "{sha}"')
              resource_lines.append(f'  end')
              resource_lines.append('')
          resource_block = "\n".join(resource_lines)

          # --- Update elspais.rb (full formula with all extras) ---
          with open("Formula/elspais.rb") as f:
              content = f.read()

          content = re.sub(
              r'url "https://files\.pythonhosted\.org/packages/[^"]+/elspais-[^"]+\.tar\.gz"',
              f'url "{sdist_url}"',
              content,
              count=1,
          )
          content = re.sub(
              r'(  sha256 ")[a-f0-9]+(".*\n  license)',
              rf'\g<1>{sdist_sha}\2',
              content,
              count=1,
          )
          content = re.sub(
              r'(  depends_on "python@3\.12"\n(?:.*?(?:conflicts_with|head)\s[^\n]*\n)*)\n(?:  resource .*?  end\n\n)*(?=  def )',
              rf'\1\n{resource_block}',
              content,
              flags=re.DOTALL,
          )

          with open("Formula/elspais.rb", "w") as f:
              f.write(content)
          print(f"Updated Formula/elspais.rb")

          # --- Update elspais-core.rb (core only: elspais + tomlkit) ---
          with open("Formula/elspais-core.rb") as f:
              content = f.read()

          content = re.sub(
              r'url "https://files\.pythonhosted\.org/packages/[^"]+/elspais-[^"]+\.tar\.gz"',
              f'url "{sdist_url}"',
              content,
              count=1,
          )
          content = re.sub(
              r'sha256 "[a-f0-9]+"',
              f'sha256 "{sdist_sha}"',
              content,
              count=1,
          )

          if "tomlkit" in deps and 'resource "tomlkit"' in content:
              tk_name, tk_url, tk_sha = next(r for r in resources if r[0] == "tomlkit")
              content = re.sub(
                  r'(resource "tomlkit" do\s+url ")[^"]+(")',
                  rf'\g<1>{tk_url}\2',
                  content,
              )
              parts = content.split('resource "tomlkit"', 1)
              parts[1] = re.sub(
                  r'sha256 "[a-f0-9]+"',
                  f'sha256 "{tk_sha}"',
                  parts[1],
                  count=1,
              )
              content = 'resource "tomlkit"'.join(parts)

          with open("Formula/elspais-core.rb", "w") as f:
              f.write(content)
          print(f"Updated Formula/elspais-core.rb")
          PYEOF

      - name: Update anspar-wf formula
        if: steps.params.outputs.package == 'anspar-wf'
        env:
          VERSION: ${{ steps.params.outputs.version }}
        run: |
          python3 << 'PYEOF'
          import json, os, re, subprocess, time, urllib.request, urllib.error

          version = os.environ["VERSION"]

          # --- Phase 1: Wait for PyPI JSON API to index the new version ---
          for attempt in range(12):
              try:
                  urllib.request.urlopen(f"https://pypi.org/pypi/anspar-wf/{version}/json")
                  print(f"PyPI JSON API has anspar-wf {version} (attempt {attempt+1})")
                  break
              except urllib.error.HTTPError:
                  print(f"Waiting for PyPI JSON API to index anspar-wf {version}... (attempt {attempt+1}/12)")
                  time.sleep(10)
          else:
              raise RuntimeError(f"PyPI JSON API never indexed anspar-wf {version} after 2 minutes")

          # --- Phase 2: Wait for pip's Simple API / CDN to propagate ---
          for attempt in range(18):
              result = subprocess.run(
                  ["pip", "install", "--dry-run", "--no-deps", f"anspar-wf=={version}"],
                  capture_output=True, text=True
              )
              if result.returncode == 0:
                  print(f"pip can resolve anspar-wf {version} (attempt {attempt+1})")
                  break
              print(f"Waiting for pip index to propagate anspar-wf {version}... (attempt {attempt+1}/18)")
              time.sleep(10)
          else:
              raise RuntimeError(f"pip could not resolve anspar-wf {version} after 3 minutes")

          # --- Fetch anspar-wf sdist info ---
          with urllib.request.urlopen(f"https://pypi.org/pypi/anspar-wf/{version}/json") as r:
              pkg = json.loads(r.read())
          sdist = next(f for f in pkg["urls"] if f["packagetype"] == "sdist")
          sdist_url = sdist["url"]
          sdist_sha = sdist["digests"]["sha256"]
          print(f"anspar-wf {version}: {sdist_sha[:16]}...")

          # --- Resolve all dependencies (with retry) ---
          for compile_attempt in range(3):
              result = subprocess.run(
                  ["pip-compile", "--no-header", "--no-annotate", "--output-file=-", "-"],
                  input=f"anspar-wf=={version}\n",
                  capture_output=True, text=True
              )
              if result.returncode == 0:
                  break
              print(f"pip-compile attempt {compile_attempt+1}/3 failed, retrying in 15s...")
              print(f"stderr: {result.stderr[-300:]}")
              time.sleep(15)
          if result.returncode != 0:
              raise RuntimeError(f"pip-compile failed after 3 attempts:\n{result.stderr}")

          deps = {}
          for line in result.stdout.strip().split("\n"):
              line = line.strip()
              if not line or line.startswith("#"):
                  continue
              clean = re.sub(r'\[.*?\]', '', line)
              if "==" not in clean:
                  continue
              name, ver = clean.split("==", 1)
              if name in ("anspar-wf", "anspar_wf"):
                  continue
              deps[name] = ver
          print(f"Resolved {len(deps)} dependencies")

          # --- Fetch sdist URL and SHA for each dependency ---
          resources = []
          for name, ver in sorted(deps.items()):
              try:
                  with urllib.request.urlopen(f"https://pypi.org/pypi/{name}/{ver}/json") as r:
                      dep_pkg = json.loads(r.read())
                  dep_sdist = next(
                      (f for f in dep_pkg["urls"] if f["packagetype"] == "sdist"), None
                  )
                  if dep_sdist:
                      resources.append((name, dep_sdist["url"], dep_sdist["digests"]["sha256"]))
                      print(f"  {name}=={ver}: OK")
                  else:
                      print(f"  WARNING: No sdist for {name}=={ver}")
              except Exception as e:
                  print(f"  ERROR: {name}=={ver}: {e}")
                  raise

          # --- Generate resource blocks ---
          resource_lines = []
          for name, url, sha in resources:
              resource_lines.append(f'  resource "{name}" do')
              resource_lines.append(f'    url "{url}"')
              resource_lines.append(f'    sha256 "{sha}"')
              resource_lines.append(f'  end')
              resource_lines.append('')
          resource_block = "\n".join(resource_lines)

          # --- Update anspar_wf.rb ---
          with open("Formula/anspar_wf.rb") as f:
              content = f.read()

          content = re.sub(
              r'url "https://files\.pythonhosted\.org/packages/[^"]+/anspar[_-]wf-[^"]+\.tar\.gz"',
              f'url "{sdist_url}"',
              content,
              count=1,
          )
          content = re.sub(
              r'(  sha256 ")[a-f0-9]+(".*\n  license)',
              rf'\g<1>{sdist_sha}\2',
              content,
              count=1,
          )
          content = re.sub(
              r'(  depends_on "python@3\.12"\n)\n(?:  resource .*?  end\n\n)*(?=  def )',
              rf'\1\n{resource_block}',
              content,
              flags=re.DOTALL,
          )

          with open("Formula/anspar_wf.rb", "w") as f:
              f.write(content)
          print(f"Updated Formula/anspar_wf.rb")
          PYEOF

      - name: Create branch and open PR
        env:
          GH_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
          PACKAGE: ${{ steps.params.outputs.package }}
          VERSION: ${{ steps.params.outputs.version }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add Formula/
          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          BRANCH="update-${PACKAGE}-v${VERSION}"
          git checkout -b "${BRANCH}"
          git commit -m "chore: Update ${PACKAGE} to ${VERSION}"
          git push -u origin "${BRANCH}"
          gh pr create \
            --title "Update ${PACKAGE} to ${VERSION}" \
            --body "Automated formula update for ${PACKAGE} v${VERSION}. Bottles will be built automatically." \
            --base main \
            --head "${BRANCH}"
